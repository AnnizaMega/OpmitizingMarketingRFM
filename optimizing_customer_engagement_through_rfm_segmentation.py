# -*- coding: utf-8 -*-
"""Optimizing Customer Engagement Through RFM Segmentation

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14djZahqpannYTnSkDpUVPs9vEMeLO-Ft

#Importing Librabies
"""

# Importing Library
import numpy as np
import pandas as pd
import datetime as dt
pd.set_option('display.float_format', lambda x: '%.5f' % x)
import matplotlib.pyplot as plt
import seaborn as sns
!pip install lifetimes squarify
import squarify
from lifetimes import BetaGeoFitter
from lifetimes import GammaGammaFitter
from lifetimes.plotting import plot_period_transactions

"""#Importing Dataset"""

df = pd.read_csv('/content/marketing_campaign.csv',sep=";")
pd.set_option('display.max_columns', None)
df

"""##Data Understanding"""

df.info()

def check_df(dataframe, head=5):
    print("################## Shape ####################")
    print(dataframe.shape)
    print("################## Types ####################")
    print(dataframe.dtypes)
    print("################## Head ####################")
    print(dataframe.head(head))
    print("################## Tail ####################")
    print(dataframe.tail(head))
    print("################## NA ####################")
    print(dataframe.isnull().sum())
    print("################## Quantiles ####################")
    print(dataframe.describe([0.01, 0.10, 0.25, 0.40, 0.50, 0.60, 0.75, 0.90, 0.99]).T)
check_df(df, 10)

"""#Data Preparation"""

df.head()

df.describe().T

df["Dt_Customer"].max()

# Convert date columns to datetime
df['Dt_Customer'] = pd.to_datetime(df['Dt_Customer'])

# Convert numeric columns to numeric types
numeric_columns = [
    'Income', 'MntFishProducts', 'MntMeatProducts', 'MntFruits', 'MntSweetProducts',
    'MntWines', 'MntGoldProds', 'NumDealsPurchases', 'NumCatalogPurchases',
    'NumStorePurchases', 'NumWebPurchases', 'NumWebVisitsMonth', 'Recency'
]

for col in numeric_columns:
    df[col] = pd.to_numeric(df[col], errors='coerce')

# Handle missing values by filling with median
for col in numeric_columns:
    df[col].fillna(df[col].median(), inplace=True)

df.info()

year_date = df["Dt_Customer"]

df["year_date"] = df["Dt_Customer"].dt.year

# We will detect our customer age
df["Age"] = df["year_date"] - df["Year_Birth"]

df.head()

# Segmentation to be able to observe the age variable in the visualisation
df["Age"] = pd.qcut(df['Age'].rank(method="first"), 3, labels=["Young", "MiddleAge", "Elder"])

# Remove the needless variable
df.drop(['Z_CostContact', 'Z_Revenue', 'Year_Birth'], axis=1, inplace=True)

df["Marital_Status"].value_counts()

# Segmentation to be able to observe the age variable in the visualisation
df["Marital_Status"] = df["Marital_Status"].replace({"Married": "Together",
                                                     "Absurd": "Single",
                                                     "Together": "Together",
                                                     "Single": "Single",
                                                     "Divorced": "Single",
                                                     "Widow": "Single",
                                                     "Alone": "Single",
                                                     "YOLO": "Single"})

df.head()

"""#Data Visualization"""

plt.figure()
plt.bar(df["Marital_Status"].value_counts().index, df["Marital_Status"].value_counts(), color = "r")
plt.xlabel("Frequency")
plt.ylabel("Marital Status")
plt.title("Marital Status - Data Frequency")
plt.show()
print(f"Number of Samples According to Marital Status \n{df['Marital_Status'].value_counts()}")

sns.countplot(x="Education", data=df)
plt.xticks(rotation = 0)
plt.show()
print(f"Number of samples According to Education \n{df['Education'].value_counts()}")

sns.violinplot(x="Education", y="Income", data=df)
plt.show()

campaign_cols = ['AcceptedCmp1', 'AcceptedCmp2', 'AcceptedCmp3', 'AcceptedCmp4', 'AcceptedCmp5', 'Response']
for col in campaign_cols:
    plt.figure(figsize=(6, 4))
    df[col].value_counts().plot(kind='pie', autopct='%1.1f%%')
    plt.title(f'{col} Distribution')
    plt.ylabel('')
    plt.show()

"""#1.Calculating RFM

## Using table tool and scoring system :
Find specific customer.
The simplest way to create customer segments from the RFM model is to use quartiles. We assign scores from 1 to 4 to recency, frequency, and monetary value, where 1 represents the best/highest value and 4 represents the lowest/worst value. A final RFM score is calculated by combining the individual scores.
"""

df.head()

# Recency
df['Recency'] = df['Recency']

# Frequency
df['Frequency'] = df['NumDealsPurchases'] + df['NumCatalogPurchases'] + df['NumStorePurchases'] + df['NumWebPurchases']

# Monetary
df['Monetary'] = df['MntFishProducts'] + df['MntMeatProducts'] + df['MntFruits'] + df['MntSweetProducts'] + df['MntWines'] + df['MntGoldProds']

rfm = df[['ID','Recency', 'Frequency', 'Monetary']]
rfm.head()

rfm.describe().T

rfm.info()

quartiles = rfm[['Recency', 'Frequency', 'Monetary']].quantile(q=[0.25, 0.5, 0.75])
quartiles

"""Creating RFM Segmentation:
This segmentation will leverage two key classes:
- High recency: This is considered positive because it indicates customers purchased recently.
- High frequency and monetary value: These are negative because it indicate factors inactive and unvaluable customers.
"""

def r_score(x, c):
    if x <= c.loc[0.25]:
        return 4
    elif x <= c.loc[0.5]:
        return 3
    elif x <= c.loc[0.75]:
        return 2
    else:
        return 1

def fm_score(x, c):
    if x <= c.loc[0.25]:
        return 1
    elif x <= c.loc[0.5]:
        return 2
    elif x <= c.loc[0.75]:
        return 3
    else:
        return 4

rfm['recency_score'] = rfm['Recency'].apply(r_score, args=(quartiles['Recency'],))
rfm['frequency_score'] = rfm['Frequency'].apply(fm_score, args=(quartiles['Frequency'],))
rfm['monetary_score'] = rfm['Monetary'].apply(fm_score, args=(quartiles['Monetary'],))

rfm.head()

rfm.recency_score.value_counts()

"""Create Segmentation Column"""

rfm['RFM_SCORE'] = rfm['recency_score'].astype(str) + rfm['frequency_score'].astype(str) + rfm['monetary_score'].astype(str)
rfm.head()

"""##RFM Segmentation

Our RFM analysis assigns the highest score of 1 to customers with:
- Highest Recency: Most recent purchase.
- Highest Frequency: Largest number of purchases.
- Highest Monetary: Highest total spending.
Let’s identify these “Champion” customers, representing our most valuable segment.
"""

# We are able to control 444 score
rfm[rfm["RFM_SCORE"] == '444']

"""This section provides suggested customer segments for further analysis. Note that the linked source uses scoring system, where 1 is the highest/best score and 4 is the lowest.
Before proceeding, let’s determine the number of customers belonging to each segment based on our scoring system.
"""

print("Best Customers: ",len(rfm[rfm['RFM_SCORE']=='444']))

print("Lost Customer: ",len(rfm[rfm['RFM_SCORE']=='144']))

print("Lost Cheap Customer: ",len(rfm[rfm['RFM_SCORE']=='111']))

print('Loyal Customers: ',len(rfm[rfm['frequency_score']==4]))

print('Big Spender: ',len(rfm[rfm['monetary_score']==4]))

print('Almost Lost: ',len(rfm[rfm['RFM_SCORE']==244]))

"""## RFM Using scatter plot tool.
Segment customers using Python. Group them into ten segments:

* Champion : 3.4 < r <= 4, 10 < FxM <= 16
* Loyal : 2.2 < r <= 3.4, 10 < FxM <= 16.
* Cannot Lose Them : 1 <= r =< 2.2, 10 < FxM <= 16.
* Potential Loyalist : 2.8 < r <= 4, 6 < FxM <= 10.
* Need Attention : 2.2 < r <= 2.8, 6 < FxM <= 10.
* At Risk : 1 <= r <= 2.2, 6 < FxM <= 10.
* New Customer : 3.4 < r <= 4, 1 <= FxM <= 6.
* Promising : 2.8 < r <= 3.4, 1 <= FxM <= 6.
* About to Sleep : 2.2 < r <= 2.8, 1 <= FxM <= 6.
* Hilbernating : 1 <= r <= 2.2, 1 <= FxM <= 6.

Define Clustre Code
"""

rfm = rfm.copy()

#Create function for define cluster code
def assign_clusterCode(row):
    if row['frequency_score'] * row['monetary_score'] > 10 and row['frequency_score'] * row['monetary_score'] <= 16 and row['recency_score'] > 3.4 and row['recency_score'] <= 4:
        return 1
    elif row['frequency_score'] * row['monetary_score'] > 10 and row['frequency_score'] * row['monetary_score'] <= 16 and row['recency_score'] > 2.2 and row['recency_score'] <= 3.4:
        return 2
    elif row['frequency_score'] * row['monetary_score'] > 10 and row['frequency_score'] * row['monetary_score'] <= 16 and row['recency_score'] >= 1 and row['recency_score'] <= 2.2:
        return 3
    elif row['frequency_score'] * row['monetary_score'] > 6 and row['frequency_score'] * row['monetary_score'] <= 10 and row['recency_score'] > 2.8 and row['recency_score'] <= 4:
        return 4
    elif row['frequency_score'] * row['monetary_score'] > 6 and row['frequency_score'] * row['monetary_score'] <= 10 and row['recency_score'] > 2.2 and row['recency_score'] <= 2.8:
        return 5
    elif row['frequency_score'] * row['monetary_score'] > 6 and row['frequency_score'] * row['monetary_score'] <= 10 and row['recency_score'] >= 1 and row['recency_score'] <= 2.2:
        return 6
    elif row['frequency_score'] * row['monetary_score'] >= 1 and row['frequency_score'] * row['monetary_score'] <= 6 and row['recency_score'] > 3.4 and row['recency_score'] <= 4:
        return 7
    elif row['frequency_score'] * row['monetary_score'] >= 1 and row['frequency_score'] * row['monetary_score'] <= 6 and row['recency_score'] > 2.8 and row['recency_score'] <= 3.4:
        return 8
    elif row['frequency_score'] * row['monetary_score'] >= 1 and row['frequency_score'] * row['monetary_score'] <= 6 and row['recency_score'] > 2.2 and row['recency_score'] <= 2.8:
        return 9
    else:
        return 10

# Apply function to each row to create 'Cluster' column
rfm['ClusterCode'] = rfm.apply(assign_clusterCode, axis=1)
rfm.head(10)

# Create function for define cluster name 10
def assign_clusterName(row):
    if row['frequency_score'] * row['monetary_score'] > 10 and row['frequency_score'] * row['monetary_score'] <= 16 and row['recency_score'] > 3.4 and row['recency_score'] <= 4:
        return 'Champion'
    elif row['frequency_score'] * row['monetary_score'] > 10 and row['frequency_score'] * row['monetary_score'] <= 16 and row['recency_score'] > 2.2 and row['recency_score'] <= 3.4:
        return 'Loyal'
    elif row['frequency_score'] * row['monetary_score'] > 10 and row['frequency_score'] * row['monetary_score'] <= 16 and row['recency_score'] >= 1 and row['recency_score'] <= 2.2:
        return 'Cannot Lose them'
    elif row['frequency_score'] * row['monetary_score'] > 6 and row['frequency_score'] * row['monetary_score'] <= 10 and row['recency_score'] > 2.8 and row['recency_score'] <= 4:
        return 'Potential Loyalist'
    elif row['frequency_score'] * row['monetary_score'] > 6 and row['frequency_score'] * row['monetary_score'] <= 10 and row['recency_score'] > 2.2 and row['recency_score'] <= 2.8:
        return 'Need Attention'
    elif row['frequency_score'] * row['monetary_score'] > 6 and row['frequency_score'] * row['monetary_score'] <= 10 and row['recency_score'] >= 1 and row['recency_score'] <= 2.2:
        return 'At risk'
    elif row['frequency_score'] * row['monetary_score'] >= 1 and row['frequency_score'] * row['monetary_score'] <= 6 and row['recency_score'] > 3.4 and row['recency_score'] <= 4:
        return 'New Customer'
    elif row['frequency_score'] * row['monetary_score'] >= 1 and row['frequency_score'] * row['monetary_score'] <= 6 and row['recency_score'] > 2.8 and row['recency_score'] <= 3.4:
        return 'Promising'
    elif row['frequency_score'] * row['monetary_score'] >= 1 and row['frequency_score'] * row['monetary_score'] <= 6 and row['recency_score'] > 2.2 and row['recency_score'] <= 2.8:
        return 'About to Sleep'
    else:
        return 'Hibernating'

# Apply function to each row to create 'Cluster' column
rfm['ClusterName'] = rfm.apply(assign_clusterName, axis=1)
rfm.head(10)

# Create column FxM
rfm['FxM'] = rfm['frequency_score'] * rfm['monetary_score']
rfm.head(10)

rfm[["ClusterName", "recency_score", "frequency_score", "monetary_score"]].groupby("ClusterName").agg(["mean", "count"])

rfm[["ClusterName", "Recency", "Frequency", "Monetary"]].groupby("ClusterName").agg(["min", "max", "mean", "count"])

# Define customer segments
segments = {
    1: "Champion",
    2: "Loyal",
    3: "Cannot loss them",
    4: "Potential Loyalist",
    5: "Need Attention",
    6: "At risk",
    7: "New Customer",
    8: "Promising",
    9: "About to Sleep",
    10: "Hibernating"
}

# Define colors for each segment
colors = {
    "Champion" : "gold",
    "Loyal" : "silver",
    "Cannot loss them" : "orange",
    "Potential Loyalist" : "green",
    "Need Attention" : "blue",
    "At risk" : "red",
    "New Customer" : "pink",
    "Promising" : "brown",
    "About to Sleep" : "gray",
    "Hibernating" : "black"
}

# Plot scatter plot with legend
plt.figure(figsize=(10, 6))
for segment, group in rfm.groupby('ClusterCode'):
    label = segments[segment]
    color = colors[label]
    plt.scatter(group['recency_score'], group['FxM'], label=label, color=color)
    # Annotate each point with CustomerID
    for customer_id, r, f in zip(group.index, group['recency_score'], group['FxM']):
        plt.annotate(customer_id, (r, f), fontsize=8)


plt.xlabel('Recency')
plt.ylabel('Frequency X Monetary')
plt.title('Customer Segmentation')
plt.legend(loc='right', bbox_to_anchor=(1.4, 0.5), ncol=1)
plt.show()

rfm.head()

data = df.copy()
data = data.drop(['Recency','Frequency','Monetary'], axis=1)
data.sort_values(by = 'ID', inplace = True)
data.head()

rfm.sort_values(by = 'ID', inplace = True)
rfm.head()

rfm.columns

df_merged = pd.merge(data, rfm, on='ID', how='outer')
df_merged.head()

df_merged = df_merged.drop(['monetary_avg','index'], axis=1)
df_merged.to_excel('Cluster_data.xlsx')

"""## CSV file exporting to create report by Tableau
rfm.to_csv('Cluster_data.csv')

Advanced Analysis with Additional Variables¶
Segment Descriptions:
About to Sleep: Customers in this segment have a relatively low recency, frequency, and monetary value. They have been inactive recently and might be slipping away.
At Risk: These customers have a high monetary value but low recency and frequency, indicating they are at risk of churning.
Can't Lose: High in all RFM values, these customers are valuable and should be retained.
Champions: These customers are highly active with recent purchases and high monetary value. They are the most valuable segment.
Hibernating: Customers with low recency, frequency, and monetary value. They might have been active in the past but are currently inactive.
Loyal Customers: High in frequency and monetary value with moderate recency. They are loyal but not recent customers.
Need Attention: These customers have a moderate monetary value but low recency and frequency. They might need attention to prevent churn.
New Customers: Recently acquired customers with low RFM values. They need nurturing to become loyal customers.
Potential Loyalists: These customers have moderate RFM values, indicating potential for becoming loyal.
Promising: Customers with low RFM values, indicating they are new or need attention to increase their value.
Business Problem Approach:
Objective:
The objective is to optimize marketing strategies and customer engagement based on RFM segments and additional variables.

Approach:
Targeting Campaigns:

Champions & Can't Lose: Focus on loyalty programs, premium offerings, and personalized experiences to retain and maximize value.
Loyal Customers: Continue engagement with tailored promotions and rewards to maintain loyalty.
Need Attention & At Risk: Implement targeted reactivation campaigns, special offers, and personalized communications to prevent churn.
Promising & About to Sleep: Nurture these segments with welcome offers, educational content, and engagement campaigns to increase their value.
Product Development:

Analyze product preferences of each segment to develop new offerings or improve existing ones.
For example, "Champions" might prefer high-end products, while "Promising" might respond well to affordable options.
Customer Experience Enhancement:

Improve customer service and support, especially for high-value segments like "Champions" and "Can't Lose."
Implement loyalty programs and VIP services for valuable segments to enhance their experience.
Retention Strategies:

Create targeted retention strategies for segments like "At Risk" and "Hibernating" to re-engage and retain customers.
Offer exclusive deals or incentives to retain "Can't Lose" customers.
Additional Variables Integration:
Additional Variables:
Customer Satisfaction Scores:

Integrate customer satisfaction scores to prioritize segments for improvement.
Identify segments with lower satisfaction scores (e.g., "At Risk" or "Need Attention") and implement strategies to enhance satisfaction.
Customer Demographics (Age, Gender, Location):

Tailor campaigns based on demographics; for example, "Champions" in a certain age group may respond better to specific offers.
Consider location-based promotions or events to engage local customers.
Interaction with Marketing Channels (Email, Social Media, etc.):

Analyze customer preferences for communication channels and adjust marketing efforts accordingly.
Focus on channels that are most effective for each segment; for instance, "Loyal Customers" might prefer personalized emails.
Product Category Preferences:

Customize product recommendations and promotions based on each segment's preferences.
For example, "Promising" customers may respond well to cross-selling related products.
Seasonality and Time of Purchase:

Take into account seasonal trends and optimize campaigns accordingly.
Offer seasonal promotions or discounts tailored to each segment's purchasing behavior.
Weighted Analysis:
Assign weights to RFM scores and additional variables based on their importance to the business.
Use these weighted scores to create a comprehensive segmentation that considers not only transaction behavior but also customer satisfaction, demographics, and interaction preferences.
Conclusion:
By integrating RFM segments with additional variables and a weighted analysis approach, businesses can create more targeted and effective marketing strategies. Understanding customer preferences, behavior, and satisfaction levels enables personalized campaigns that drive engagement, retention, and ultimately, revenue growth.

Note:
Highlighted segments such as "Champions" and "Can't Lose" remain critical for high-value retention strategies. However, the inclusion of additional variables provides a deeper understanding of customer segments, allowing for more nuanced and impactful marketing decisions.
"""

rfm = rfm.reset_index()

df_ClusterName = rfm.groupby('ClusterName')['ID'].count().reset_index()
df_ClusterName

import squarify
import matplotlib.colors as mcolors
cmap = plt.cm.Set3
mini = min(df_ClusterName['ID'])
maxi = max(df_ClusterName['ID'])
norm = mcolors.Normalize(vmin=mini, vmax=maxi)
colors = [cmap(norm(value)) for value in df_ClusterName['ID']]
fig = plt.gcf()
fig.set_size_inches(14, 8)
squarify.plot(sizes=df_ClusterName['ID'],
              label=df_ClusterName['ClusterName'], alpha=1, color=colors)
plt.axis("off")
plt.show()

rfm.head()

"""# Additional ONLY

# #2.CLTV
"""

df.head()

df.loc[(df["Dt_Customer"] == df["Dt_Customer"].max(), "Recency")].sort_values(ascending=False).head(1)

df["Dt_Customer"].max()

current_Day = df["Dt_Customer"].max()
current_Day

df["Frequency"] = rfm.Frequency
df["Monetary"] = rfm.Monetary

"""##2.1 Creating CLTV"""

cltv_df = pd.DataFrame()

df["monetary_avg"] = rfm["Monetary"] / rfm["Frequency"]

cltv_df = df.groupby("ID").agg({"Dt_Customer":lambda x: (current_Day - x).dt.days,
                               "Recency": lambda x: x,
                               "monetary_avg": lambda x: x,
                              "Frequency": lambda x: x})

cltv_df.columns = ["T", "Recency", "Monetary", "Frequency"]

cltv_df  = cltv_df[(cltv_df["Frequency"] > 0)]

cltv_df = cltv_df[cltv_df["T"] > cltv_df["Recency"]]

cltv_df

#Rececncy at every week
cltv_df["Recency"] = cltv_df["Recency"] / 7
cltv_df["T"] = cltv_df["T"] / 7

cltv_df["Recency"].max()

cltv_df["T"].min()

cltv_df

"""#3.Creating BG-NBD Model"""

bgf = BetaGeoFitter(penalizer_coef=0.001)

bgf.fit(cltv_df['Frequency'],
        cltv_df['Recency'],
        cltv_df['T'])

"""The customers we expect to place the most orders from us in the 3-month period"""

bgf.predict(12,
        cltv_df['Frequency'],
        cltv_df['Recency'],
        cltv_df['T']).sort_values(ascending=False).head(8)

"""The customers we expect to place the most orders from us in the 4-month period"""

bgf.predict(16,
        cltv_df['Frequency'],
        cltv_df['Recency'],
        cltv_df['T']).sort_values(ascending=False).head(10)

"""The customers we expect to place the most orders from us in the 6-month period"""

bgf.predict(24,
        cltv_df['Frequency'],
        cltv_df['Recency'],
        cltv_df['T']).sort_values(ascending=False).head(8)

"""#4.Creating GAMMA-GAMMA Model"""

ggf = GammaGammaFitter(penalizer_coef=0.01)

ggf.fit(cltv_df['Frequency'], cltv_df['Monetary'])

"""Monetary values left to us per customer"""

ggf.conditional_expected_average_profit(cltv_df['Frequency'],
                                        cltv_df['Monetary']).sort_values(ascending=False).head(10)

from lifetimes.plotting import plot_frequency_recency_matrix
plot_frequency_recency_matrix(bgf)

from lifetimes.plotting import plot_probability_alive_matrix
plot_probability_alive_matrix(bgf)

# Assessing model fit
from lifetimes.plotting import plot_period_transactions
plot_period_transactions(bgf)

"""#5.Calculation CLTV with BG-NBD and GAMMA-GAMMA Model"""

cltv = ggf.customer_lifetime_value(bgf,
                                   cltv_df['Frequency'],
                                   cltv_df['Recency'],
                                   cltv_df['T'],
                                   cltv_df['Monetary'],
                                   time=3,  # 3 month
                                   freq="W",  # week
                                   discount_rate=0.01)

cltv.sort_values(ascending=False)

cltv_final = cltv_df.merge(cltv, on="ID", how="left")

cltv_final.sort_values("clv", ascending=False).head(10)

"""#6.Create CLV Segmentation


"""

cltv_final["segment"] = pd.qcut(cltv_final["clv"], 4, labels=["D", "C", "B", "A"])

cltv_final

cltv_final.groupby("segment").agg({"count", "mean", "sum"})

